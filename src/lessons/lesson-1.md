---
permalink: /:slug
---

# 1) [Setup Environment, Debugging, Automatization :wrench:](https://docs.google.com/document/d/1XRFitry7KHvvwzNHPsX23rxEa5r0wjqcTKz3qAKV3eM/edit)

[[toc]]


## Установить/настроить систему (Linux/MacOs)

У меня windows :disappointed: :gun: ... :skull: 

## Установить PHP 7.2

::: tip Статистика

PHP использую 80% всех сайтов на октябырь 2018 года:

![](https://i.imgur.com/0OtSY7n.png)

Использование версий:

![](https://i.imgur.com/rIhkEIo.png)

[Источник](https://w3techs.com/technologies/details/pl-php/all/all)
, хороший сайт, много статистики по разным темам.
:::

Стабильная версия: **PHP 7.2.10** (13 Sep 2018), смотрел [тут](http://php.net/downloads.php)

## Установить/настроить Nginx + PHP-FPM / Apache + mod_php

Apache и Nginx — 2 самых широко распространенных веб-сервера с открытым исходным кодом в мире. 
Вместе они обслуживают более 50% трафика во всем интернете. 
Оба решения способны работать с разнообразными рабочими нагрузками и взаимодействовать 
с другими приложениями для реализации полного веб-стека.

Несмотря на то, что у Apache и Nginx много схожих качеств, 
их нельзя рассматривать как полностью взаимозаменямые решения. 
Каждый из них имеет собственные преимущества и важно понимать какой веб-сервер выбрать в какой ситуации.

::: tip Статистика 

Процент веб-сайтов использующих Apache и Nginx. 

![](https://i.imgur.com/Zh0cB92.png)

Хоть Apache используют немного больше сайтов, 
Nginx обычно используют самые топовые сайты.

![](https://i.imgur.com/CHHUqyH.png)

[Полная статистика.](https://w3techs.com/technologies/comparison/ws-apache,ws-nginx,ws-microsoftiis)


![](https://i.imgur.com/ugkrbY0.png)

[Источник](https://www.similartech.com/compare/apache-vs-nginx)

---

Кстати, [Unix самая популярная ОС для веб-серверов.](https://w3techs.com/technologies/overview/operating_system/all)
MacOS используют меньше 0.1% сайтов.

![](https://i.imgur.com/tG4e1ar.png)
:::


### Apache + mod_php

<img :src="$withBase('/images/lesson-1/apache.png')" alt="foo">

**Apache** — веб-сервер, то есть который принимает HTTP запросы и дает HTTP ответы. 

::: tip Интересный факт
HTTPS это тот же протокол HTTP, 
но работающий через шифрованные SSL и TLS.
:::

Apache является кроссплатформенным ПО, в отличие от Nginx.

Существует более 500 модулей.

Через модули может поддерживать языки: PHP, Python, Ruby, Perl, ASP.

**mod_php** - обычный модуль Apache, добавляет поддержку PHP.

Apache легко может раздавать статический и динамический контент (у Nginx не так просто с динамическим контентом).

**Динамический контент** - контент который прежде чем вернуть браузеру нужно выполнить на сервере. 
Даже простой `echo` на PHP будет динамическим контентом так как требует выполнения на сервере. 

Для лучшего понимания: **статитеский контент** - это .js, .css, обычный .html(без php), картинки и т.д.
Этот контент будет выполнятся непосредственно в браузере и не требует серверного выполнения.

::: tip Интересные факты
С апреля 1996 и до настоящего времени является самым популярным HTTP-сервером в Интернете. 
[Статистика Netcraft показывает следующие данные об использовании Apache:](https://ru.wikipedia.org/wiki/Apache_HTTP_Server#%D0%98%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F)

- в августе 2007 года он работал на 51 % всех веб-серверов
- в мае 2009 года — на 46 %
- в январе 2011 года — на 59 %, т.е. более чем на 160 млн сайтов
- в январе 2016 года — на 33,56 %, т.е. более чем на 304 млн сайтов.

Apache имеет долю рынка в России до 17,50%. Тогда как
[Nginx — самый популярный веб-сервер в России с долей рынка 65,78%](https://www.runfo.ru/statistika-rossijskogo-interneta).

---

Аpache является лидером в большинстве стран, включая США, Японию, Германию, Францию ​​и 217 других стран. 
:::

### Nginx + PHP-FPM
<br>
<img :src="$withBase('/images/lesson-1/nginx.png')" alt="foo">

**Nginx** (e**ngin**e **x**; произносится как э́нгинкс или э́нжин-и́кс) — веб-сервер только для Unix-подобных ОС.
Но разве кто-то в **2к18** размещает веб-сервер на Windows?
::: tip Интересные факты
Разработан русским Программистом Игорем Сысоевым.

Не удивлюс что именно из-за этого он такой лидер в СНГ.

Nginx является лидером в России, Украине, Китае, Индонезии и 14 других странах.

[![](https://i.imgur.com/hM6fXmq.png?1)](https://i.imgur.com/hM6fXmq.png?1)

[Источник с интерактивной картой](https://www.similartech.com/compare/apache-vs-nginx)

По данным W3Techs, nginx наиболее часто используется на высоконагруженных сайтах, 
занимая первое место по частоте использования среди 100 000 самых посещаемых сайтов в мире — больше половины из них работает на nginx.

[По данным Netcraft](https://news.netcraft.com/archives/2018/02/13/february-2018-web-server-survey.html) 
на февраль 2018 года, число сайтов, обслуживаемых nginx, превышает 447 миллионов, 
что делает его третьим по популярности веб-сервером в мире. 
Доля среди активных сайтов — 21,13 %, что ставит nginx на второе место после веб-сервера Apache

По данным российского регистратора REG.RU, nginx является самым популярным веб-сервером доменных зон 
[.ru](https://statonline.ru/metrics/web_server_soft?tld=ru), 
[.рф](https://statonline.ru/metrics/web_server_soft?tld=rf) и 
[.su](https://statonline.ru/metrics/web_server_soft?tld=su), 
обслуживая более половины каждого сегмента.
:::

Nginx не имеет возможности самостоятельно обрабатывать запросы к динамическому контенту. 
Для обработки запросов к PHP или другому динамическому контенту Nginx должен передать запрос (проксировать) внешнему инструменту (популярное решение это `php-fpm`) для исполнения, 
подождать пока ответ будет сгенерирован и передать клиенту.

**FastCGI Process Manager (FPM, он же `php-fpm`)** — является альтернативной реализацией PHP FastCGI 
с несколькими дополнительными возможностями обычно используемыми для высоконагруженных сайтов.

А что такое FastCGI?

**FastCGI** — клиент-серверный протокол взаимодействия веб-сервера и приложения, 
дальнейшее развитие технологии CGI. 
По сравнению с CGI является более производительным и безопасным.

То есть FPM это улучшенный FastCGI, а FastCGI это улучшенный CGI. 
Соответственно FPM на сегодняшний день самый актуальный из них.

Вообще FPM, FastCGI и CGI это все SAPI у PHP.

**SAPI** — это внешний уровень абстракции, предназначенный для встраивания интерпретатора в другие приложения 
и отвечает за его работу (запуск, остановка, передача скриптов на исполнение, доступ к внешним данным). 
Существует несколько основных SAPI определяющих способы запуска и использования PHP:

1. В качестве модуля к веб-серверу (например, для Apache модуль `mod_php`). 
В этом случае интерпретатор PHP выполняется в окружении процесса веб-сервера. 
Веб-сервер управляет количеством запущенных процессов PHP и сообщает им какие скрипты требуется исполнить.
2. **CGI SAPI**. Использование CGI подразумевает запуск нового процесса для обработки каждого запроса. 
Для исполнения PHP скрипта веб-сервер запускает `./php-cgi /path/to/script.php`. 
Сам принцип такого использования подразумевает, что интерпретатор PHP исполняет только один скрипт, после чего заканчивает свою работу.
Затраты на запуск процесса интерпретатора и его инициализацию очень часто сопоставимы или даже превышают затраты на исполнение PHP скрипта. 
Для решения этой проблемы в CGI SAPI был введён режим **FastCGI**. 
В этом режиме PHP интерпретатор запускается как независимый сервер, обрабатывающий входящие запросы на исполнение PHP скриптов по протоколу FastCGI, 
что позволяет ему работать с любым веб-сервером поддерживающим этот протокол.
3. **FPM SAPI**, известный как `php-fpm` — это другая реализация протокола FastCGI. 
В кратце, просто добавили много улучшений, изначально создан Андреем Нигматулиным, 
в дальнейшем разрабатывали несолько человек. 
Начиная с версии **PHP 5.3.3** `php-fpm` был включён в PHP как отдельное SAPI.
4. В качестве скрипта командной строки (**CLI SAPI**), являющегося исполняемым файлом, который вызывается пользователем из командной строки; 
скрипт выполняется в окружении вызвавшего пользователя. 
В этом случае возможно использование PHP для создания клиентских GUI-приложений 
и решения административных задач в операционных системах UNIX, Linux, Microsoft Windows, Mac OS X и AmigaOS. 
Однако в таком качестве он не получил распространение, отдавая пальму первенства Perl, Python и VBScript.

> Начиная с версии PHP 5.4.0 в CLI SAPI появилась возможность запуска PHP как отдельного HTTP сервера. 
> Однако этот режим предназначен исключительно для разработки, так как запускает только один процесс интерпретатора и выполняет все запросы исключительно последовательно.

Это про команду `php -S localhost:8000`. [Подробнее.](http://php.net/manual/ru/features.commandline.webserver.php)

### Различия между Nginx и Apache
Знания взяты из [этой](https://habr.com/post/267721/)
и [этой](https://ekaterinagoltsova.github.io/posts/apache-vs-nginx/) статей
, ниже выделил самое главное для себя.

#### Статический и динамический контент
Основные различия между Apache и Nginx в том как они обрабатывают запросы к статическому и динамическому контенту. 
Про это я уже писал выше. Для Nginx нужно ставить FPM. 
В то время как у Apache есть возможность обрабатывать динамический контент средствами самого Apache, это упрощает конфигурирование. 
Интерпретотар PHP может быть просто подключен с помощью модуля `mod_php`.
Нет необходимости настраивать взаимодействие с дополнительным софтом, динамический модуль может быть легко отключен в случае изменившихся требований.

Однако, Nginx + FPM имеет и свои преимущества: статический контент будет возвращен клиенту простым способом 
и запросы к интерпретатору будут выполняться только тогда когда они нужны. 
Apache тоже может работать в такой манере, но тогда это лишит его преимуществ.

Есль подитожить:

**Apache** — может генерировать как статический контент, так и динамический. С этим никаких проблем нет. 
Прекрасно подойдет тем, кто не хочет заморачиваться с проксированием и настройкой дополнительного инструмента для генерации динамики, 
ведь Apache — это готовое работающее решение.

**Nginx** — отдает только статику и из коробки генерировать динамический контент не умеет. 
Если использовать nginx и генерировать динамический контент на своем сайте, то придется проксировать запросы тому, кто это делать умеет (apache, `php-fpm` и др.). 
Поэтому, разработчикам придется настраивать дополнительную связку, которая усложняет архитектуру, например nginx + apache 
(кстати в этой связке, Apache называют бекенд сервером, а Nginx — фронтендом), nginx + `php-fpm` и др.


#### Метод обработки соединений с клиентами
**Apache** на каждый запрос от клиента создает отдельный процесс (или поток, зависит от выбранного mpm модуля). 
Выглядит это следующим образом - клиент отправляет запрос, веб-сервер создает отдельный процесс на этот запрос, 
отвечает клиенту и блокирует процесс до тех пор, пока клиент не закроет соединение. 
Это легко и просто в реализации, дебаге и мониторниге, 
но … Как можно догаться догадаться, если имеется highload проект, то.. дела плохи. 
Процесс в любой ОС требует памяти и ресурсов, а когда процессов становиться неприлично много, 
обработка соединений неприлично замедляется, память кончается, CPU растет. 
Для мелких проектов такая реализация архитектуры обработки соединений не добавит головной боли, 
но для высоконагруженных проектов придется ставить очень мощное железо или искать альтернативные варианты.

**Nginx** состоит из master-процесса и нескольких дочерних процессов. 
Мастер процесс обычно один — он создает дочерние процессы (воркеры, загрузчик кеша и кеш менеджер), считывает конфигурацию и открывает порты. 
Воркеров обычно несколько, разработчики nginx советуют количество воркеров определять равным числу ядер машины. 
Эти дочерние процессы буду обслуживать все соединения с клиентами в неблокирующей манере. 
В nginx используется бесконечный цикл, который бежит по всем соединениями и отвечает на запросы клиентов. 
Когда соединение закрывается, оно удаляется из event loop. 
Это решение идеально подходит для проектов, которые обслуживающих 10к+ соединений одновременно. 
При этом, загрузка CPU и использование памяти обычно равномерны, без видимых пиков.



#### Распределенная конфигурация против централизованной
**Apache** полюбился разработчикам и сисадминам не в последнюю очередь из-за возможности конфигурировать обработку соединений на уровне директорий(через файл `.htaccess`). 
Делается это с помощью скрытого файла .htaccess, позволяющего настраивать права доступа, авторизацию, аутентификацию, политику кеширования и др правила. 
Это довольно-таки удобное решение для пользователей, потому что позволяет менять конфигурацию на лету, без перезагрузки сервера и без наличия доступа к основному конфигу сервера. 
Но также имеется маленький минус — Apache каждый раз при обработке соединений ищет файл .htacces и считывает с него информацию, что естественно замедляет выдачу ответа клиенту 
(кстати, поддержку настройки конфигурирования на уровне директорий можно и отключить).

**Nginx** не интерпретирует файлы `.htaccess` и не предоставляет механизм конфигурирования на уровне директорий за пределами основного конфигурационного файла. 
Этот подход может показаться менее гибким чем в случае с Apache, но он имеет свои преимущства:

- Основное преимущество — это улучшенная производительность. 
- Безопасность. Пользователи в конфиге на уровне директории могут указать что-то не так и будет дыра в безопасности. 
А так администратор может контролировать весь сервер и предотвращать оишбки безопасности.

Если необходимо обновить конфигурацию, то необходимо отправить сигнал SIGHUP мастеру, который в свою очередь перезагружает конфигурацию и плавно завершает работу воркеров.

Как по мне то Apache ничем не уступает, можно включить поведение как у Nginx. 
А если грамотно писать `.htaccess`, то не будет дыр в безопасности. 
**Интересно** можно ли сделать так: есть единий конфиг сервера и в котором можно указать правила для директорий 
прямо в этом конфиге, указывая пути на директории и правила для них? 
Или, например, указывать в главном конфиге в какой папке содержатся `.htaccess`, 
неужели нет такого решения? :smile:

####  Работа с модулями
**Apache** за долгое время существования обзавелся около 60 официальными модулями, и еще большим числом неофициальных(всего модулей по словам википедии больше 500). 
Модули динамически подключаются, не требуют сборки и перезагрузки веб-сервера.

**Nginx** имеет около 130 официальных [модулей](https://www.nginx.com/resources/wiki/modules/). 
В отличие от Apache, модули Nginx не могут быть динамически загружены на лету и требуют сборки. 
Это гораздо сложнее, но считается безопаснее.

#### Интерпретация запросов
**Apache** имеет возможность интерпретировать запрос как физический ресурс в файловой системе или как URI, который требует дополнительной обработки.

**Nginx** создан, чтобы работать и в качестве веб-сервера, и в качестве прокси-сервера. 
По этой причине он работает в первую очередь с URI, транслируя их при необходимости в запросы к файловой системе.

#### Работа со скриптовыми языками
Как я писал выше модуль `mod_php` добавляет в **Apache** PHP, но все хосты вынуждены работать с одной и той же версией php и одним конфигурационным файлом.

В случае с **Nginx**, каждый виртуалхост будет выполняться в отдельном процессе и, соответственно, может использовать разные версии php (python/ruby/perl и др.). 
Каждый процесс может иметь свою собственную независимую конфигурацию.

Вообще, в высоконагруженных проектах удобнее держать раздельно **Nginx** и PHP. 
По отдельности их проще мониторить, ловить баги или узкие места. 
«Все-в-одном» **Apache** + mod_php в этом плане менее удобен.

#### Скорость работы
Скорость работы веб-сервера обычно измеряют для 2-х случаев отдачи контента: для статики и динамики. 
На основе тестов производительности, **Nginx** примерно в 2.5 раза быстрее отдает статику, чем **Apache**. 
Это довольно-таки большое превосходство. Если вам необходимо обслуживать большое количество статического контента, Nginx — лучший выбор. 
Во время тестирования отдачи динамического контента, Apache и Nginx показывают примерно одинаковые результаты. 
С точки зрения памяти, оба сервера используют один и тот же объем ресурсов. 
(подробнее о тестах скорости отдачи контента можно почитать [здесь](http://www.speedemy.com/apache-vs-nginx-2015/))

#### Поддержка ОС
**Apache** прекрасно работает на Unix-подобных операционных системах, 
также разработчики этого веб-сервера полностью поддерживают линейку Microsoft Windows, включая последние версии этой ОС.

**Nginx** также поддерживает работу на множестве Unix-подобных ОС и имеет некоторую поддержку Windows, которая не является полной. 
Но разве кто-то в наше время размещает веб-сервер на Windows? (по статистике 30% все же размещают)

#### Сообщество и поддержка
**Apache** на рынке с 1995 года, что очень немалый срок, обеспечивший инструменту огромное сообщество и поддержку с его стороны. 
Практически на все вопросы на Stack Overflow уже есть исчерпывающие ответы. Коммерческой поддержки нет.

**Nginx** веб-сервер более молодой, на рынке он с 2004 года, что также не помешало большому сообществу сформироваться и поддерживать друг друга. 
Nginx, в отличие от Apache, имеет коммерческую версию Nginx Plus, которая дополнена инструментами балансировки нагрузки, мониторинга, потоковой передачи медиа и др.

#### Документация и обучение
И у **Apache** и у **Nginx** присутствует доступная официальная документация.

**Nginx** предлагает платное обучение, включающее в себя онлайн курсы, практические занятия и экзамен. 
По окончании курса все участники получают сертификаты. 
Например, сдать экзамен по основам Nginx и получить официальный сертификат обойдется в 49$ 
(подробнее [здесь](https://university.nginx.com/)).

---

Я не про чтобы делать выводы, но как по мне Nginx получше, но требует больше настроек и компетентности. 
Не просто так Nginx используют больше те сайты, которые в топе (в верху картинка статистики) и те которые имеют большую нагрузку.
Nginx в любом случае сильно превосходит Apache по скорости статического контента, 
но когда речь заходит о динамическом, то тут нет разницы (почти везде именно динамический).
Apache хорош для новичков и маленьких проектов, не требует настроек. 


## Установить/настроить PHPStorm

Оффициальный гайд: [https://www.jetbrains.com/help/phpstorm/meet-phpstorm.html]()

### Установить плагины

Оффициальная документация: [Managing Plugins](https://www.jetbrains.com/help/phpstorm/managing-plugins.html)

Чтобы быстро открыть плагины:

- `Ctrl+Alt+S` и выбрать **Plugins**
- `Ctrl+Shift+A` и ввести **Plugins**


#### Список плагинов: 

- [Symfony Plugin](https://plugins.jetbrains.com/plugin/7219-symfony-plugin)
— поддержка фреймворка Symfony.

Можно настроить в `Languages & Framework > PHP > Symfony` 

- [PHP Annotation](https://plugins.jetbrains.com/plugin/7320-php-annotations)
— поддержка анотаций для PHP. 

Можно настроить в `Languages & Framework > PHP > Annotations` 

[Подробнее о настройках](https://github.com/Haehnchen/idea-php-annotation-plugin#settings)

- [PHP Inspections (EA Extended)](https://plugins.jetbrains.com/plugin/7622-php-inspections-ea-extended-)
— статический анализатор кода PHP.

**Статический** это когда берется исходный код и анализируется без выполнения.
Часто IDE умеют работать с такими анализаторами через плагины или даже могут 
просто находит самостоятельно конфиг анализатора в проекте и по нему запускать анализатор IDE.
Это очень помогает, особенно для новичков которые делают банальные ошибки. 

Благодаря анализатору можно быстро научится не делать оишбок и некоторым анализаторам 
можна задавать стиль кода, можна выбрать популярный стиль и писать на одном стиле в команде разработчиков.

В начале XXI века термин **Lint** нарицательным для всех программ такого типа.

По опыту с JS могу поделиться что там это распространено по многим современным проектам 
(мало джикьюерщиков про это знают) и там это мощно реализовано через 
[Eslint](https://github.com/eslint/eslint). Очень много правил проверок реализовано,
все детально можно настроить, кучи плагинов под разные стили, фреймворки, библотеки.
В этом проекте в исходнике тоже можно увидеть конфиг ".eslintrc.js" для JS.

**Динамический** анализ кода это когда уже выполняется код. 
По крайнер мере в JS это очень редкое явление.
Лично я не до конца понимаю как это даже почитав некоторые статьи. 

Вот пример с чем может помочь динамический анализатор: 

![](https://i.imgur.com/u2lVTNi.png)

Горячие клавиши:

`Alt + Shift + I` — для проверки текущего файла текущим профилем

`Ctrl + Alt + Shift + I` — запустить проверку по имени

`Ctrl + Shift + F4` — закрыть результаты проверки


- [PHP composer.json support](https://plugins.jetbrains.com/plugin/7631-php-composer-json-support)

— Добавляет auto completion и делает проверку на поддержку файла composer.json в проектах PHP.


- [.ignore](https://plugins.jetbrains.com/plugin/7495--ignore)

— Возможность создавать **.\*ignore** файлы по многим шаблонам, причем их можно комбинировать, подсвечивает правила в таких файлах, подсвечивает игнорируемые файлы/папки.

![](https://i.imgur.com/WXHEZjN.png)

Есть еще сайтик [gitignore.io]() с похожим функционалом.

![](https://i.imgur.com/xMYYp0Y.png)

- [String Manipulation](https://plugins.jetbrains.com/plugin/2162-string-manipulation)

Переключение между стилями (camelCase, kebab-lowercase, KEBAB-UPPERCASE, snake_case, SCREAMING_SNAKE_CASE, dot.case, words lowercase, Words Capitalized, PascalCase)


::: tip Интересный факт
[По результатам по крайней мере одного исследования](https://ieeexplore.ieee.org/document/5521745?reload=true&tp=&arnumber=5521745)
, читатели гораздо быстрее воспринимают информацию, написанную в snake_case, чем написанную в CamelCase.
:::


- [Adders/Removers Generator](https://plugins.jetbrains.com/plugin/8132-adders-removers-generator)

— позволяет создавать методы добавления и удаления для свойств класса на основе аннотированного типа 
([пример](https://github.com/ruslan-polutsygan/phpstorm-adder-remover-generator-plugin#before-1)).

Имеет всего 2.5к скачиваний.


- [PHP Class Templates](https://plugins.jetbrains.com/plugin/9640-php-class-templates)

— возможность через контекстное меню создавать классы по шаблонам

Имеет всего 4.3к скачиваний.

Похожий функционал есть в PhpStorm из коробки, но там в контекстном меню будут идти все шаблоны подряд.
PHP Class Templates

**До:**

![](https://i.imgur.com/1HMQ9er.png)

**После:**

![](https://plugins.jetbrains.com/files/9640/screenshot_16864.png)

Подробней как делать свои шаблоны: [1](https://confluence.jetbrains.com/display/PhpStorm/File+Templates+in+PhpStorm), [2](https://www.jetbrains.com/help/phpstorm/using-file-and-code-templates.html).

- [PHPUnit Enhancement](https://plugins.jetbrains.com/plugin/9674-phpunit-enhancement)

— Плагин для помощи с PHPUnit тестированием. 
Интеллектуальное автозаполнение, навигация по коду и функции рефакторинга для методов mocked классов.

Имеет всего 18к скачиваний.

### Ознакомиться

- [Скринкаст PhpStorm Live Templates](https://symfonycasts.com/screencast/phpstorm/live-templates) 

У меня не было папки templates в `C:\Users\User\.PhpStorm2018.2\config`, поэтому не поставил.

- [Live Templates для Symfony](https://github.com/knpuniversity/phpstorm-settings)

- [Скринкаст phpstorm](https://symfonycasts.com/screencast/phpstorm)

От себя могу добавить [такой](https://laracasts.com/series/how-to-be-awesome-in-phpstorm) скринкаст. 
На [laracasts.com](laracasts.com) есть много видео.

Для часто используемых конструкций есть Live Templates, это когда пишешь коротко слово, 
нажимаешь Tab (клавиша настраивается) и появляется конструкция языка в которой по очереди можно указать параметры.

Насколько я знаю с некоторыми плагинами уже идут Live Template, с плагином Symfony 
добавился только Twig (может он даже из коробки PhpStorm'a), было бы удобно чтобы сразу 
были Live Template для самого php впридачу.

![](https://i.imgur.com/cyApH9X.png)

## Ознакомится с основами Git 
- [Слайды](http://inso.im/hello-git/#/14)
- [Книга](https://git-scm.com/book/ru/v2)

Этому будет отдельный урок, там уже распишу главное. 
На уроке упоминали что есть 3 способа задать игнорируемые файлы, вот они:


### 3 области где можно задать правила игнорирования


1. **На уровне проекта**

    Правила задаются через `.gitignore` файл в корне проекта.
    Самый популярный вариант.

2. **На уровне компьютера**

    Правила хранятся в `~/.gitexcludes` (Unix) и `C:\Users\User\.gitexcludes` для Windows.

    В этой же директории в файле `.gitconfig` должно быть прописано в разделе `core`:
    
    ```bash
    [core]
      excludesfile = ~/.gitexcludes
    ```
    
    Как по мне это удобно, но если работаешь в команде, то у всех может быть разные
    правила на уровне компьютера, а скопировать правила с одного компа на другой не 
    удобно и придется делать для всех. А что если это популярная open source библиотека, 
    всем придетсья ставить твои глобальные правила? Поэтому я не вижу в этом смысла.
    
    ::: tip Трюк
    Если в глобальном игноре задано правило игнорировать что-то, то это правило 
    можно отменить на уровне проекта написав перед правилом `!`, пример: `!.idea`
    :::

3. **На уровне локального репозитория**

    Правила задаются для проекта но на уровне локального репозитория, то есть только в вашей копии проекта.
    Для этого надо написать правила в `.git/info/exclude`
    
    Это игнорирование можно использовать, например, 
    если вы делаете какие-то наработки и еще не готовы поделиться с ними.
    
    ::: tip Совет
    Если вы сделали изменение в файле/файлах перед тем как добавили их в игнорируемые, 
    нужно выполнить:
    
    `git update-index --assume-unchanged [<file>...]`
    
    А чтобы отменить предыдущую комманду:
    
    `git update-index --no-assume-unchanged [<file>...]`
    
    Можно добавить алиасы в `[alias]` секцию:
    
    ```bash
    [alias]
    ignore = update-index --assume-unchanged
    unignore = update-index --no-assume-unchanged
    ignored = !git ls-files -v | grep "^[[:lower:]]"
    ```
    
    Можно будет использоват так: `git ignore [<file>...]`, `git unignore [<file>...]`,
    `git ignored` для отображения игнорируемых.
    
    Инфа [отсюда](https://stackoverflow.com/questions/1753070/how-do-i-configure-git-to-ignore-some-files-locally).
    :::

На хабре есть спорное мнение для чего можно использовать 2 последних правила.

Там утверждается что:

> Иногда встречаю в файле .gitignore то, чего там быть никак не должно. 
Например, папка .idea, в которой лежат конфиги известных IDE от JetBrains. 
Это часть вашего рабочего окружения и она никаким боком не относится к проекту и репозиторию. 
Если над проектом работает несколько человек и каждый из них добавит конфиги своего окружения в .gitignore, то он превратится в нечитаемую помойку.

Но я другоо мнения как и эти люди:

![](https://i.imgur.com/iKKMmI9.png)
![](https://i.imgur.com/fROnKvL.png)
![](https://i.imgur.com/diyod11.png)



## Установить расширение PHP - Xdebug

### Конфигурация

```bash
xdebug.profiler_enable_trigger=1
xdebug.remote_enable=1
xdebug.remote_host=127.0.0.1
xdebug.remote_port=9000
xdebug.var_display_max_depth=10
xdebug.max_nesting_level=20000000
xdebug.remote_autostart=0
```

### Сконфигурировать PHPStorm для работы с Xdebug 


[Оффициальный гайд для PhpStorm.](https://www.jetbrains.com/help/phpstorm/configuring-xdebug.html)

Я ставил Xdebug для своей версии php, но мне выдавало ошибку:

```bash
$ php --version
Failed loading D:\xampp\php\ext\php_xdebug-2.6.1-7.1-vc14-x86_64.dll
PHP 7.1.4 (cli) (built: Apr 11 2017 20:08:12) ( ZTS MSVC14 (Visual C++ 2015) x86
 )
Copyright (c) 1997-2017 The PHP Group
Zend Engine v3.1.0, Copyright (c) 1998-2017 Zend Technologies
```

Решил проблему довольно легко наткнувшись на сайт [xdebug.org/wizard.php](http://xdebug.org/wizard.php).
Туда нужно вставить информацию о `phpinfo()`, сайт определит какой бинарник скачать (`.dll`) 
и что написать в конфиг.

Кстати, проблема скорее всего была в том что я использую 32 bit версию Apache, а скачивал 
64 bit Xdebug.

![](https://i.imgur.com/oPcFMbS.png)

---

Чтобы понять что Xdebug установлен у вас в 
`File | Settings | Languages & Frameworks | PHP` в окне CLI Interpreters должно быть:

![](https://i.imgur.com/lJCb5ix.png)

---

По умолчанию в Laravel, как скорее всего и в Symfony, отключен вывод ошибок через Xdebug.
Чтобы включить надо:

```php
ini_set('display_errors', 1);
restore_error_handler();
```

В этом вряд ли есть смысл, но полезно знать.

### Установить браузерное расширение

| Браузер           | Расширения отладки браузера |
| :---              | :---:                       |
| Chrome            | [Xdebug Helper](https://chrome.google.com/extensions/detail/eadndfjplgieldjbigjakmdgkmoaaaoc) |
| Firefox           | [The easiest Xdebug](https://addons.mozilla.org/en-US/firefox/addon/the-easiest-xdebug/) or [Xdebug Helper](https://addons.mozilla.org/en-US/firefox/addon/xdebug-helper-for-firefox/) |
| Safari            | [Xdebug Toggler](https://github.com/benmatselby/xdebug-toggler) |
| Opera             | [Xdebug launcher](https://addons.opera.com/addons/extensions/details/xdebug-launcher/) |
| Internet Explorer	| [PhpStorm bookmarklets generator](https://www.jetbrains.com/phpstorm/marklets/) |
